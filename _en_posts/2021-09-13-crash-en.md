---
layout: post
title: "iOS 10.x memery Crash Investigation Record"
subtitle: "This is a subtitle"
date: 2021-09-13
author: "PaysonChen"
header-img: "img/post-bg-ios9-web.jpg"
lang: en
tags: []
---

Update: 2021-09-07

[TOC]



## 1. Basic information

Final stacking position:

```
XXX -[KSKitBaseModel encodeWithCoder:] (KSKitBaseModel.m:)
XXX -[KSBaseModel encodeWithCoder:] (KSBaseModel.m:)
XXX -[KSBaseModel encodeWithCoder:] (KSBaseModel.m:)
```

## Analysis

### 2.1 Stack analysis

Track multiple Crash stacks.

XXX Stack 1:

```
9 XXX 0x0000000103bf4718 -[KSKitBaseModel encodeWithCoder:] (KSKitBaseModel.m:42)
11 XXX 0x0000000100721688 -[KSBaseModel encodeWithCoder:] (KSBaseModel.m:50)
11 XXX 0x0000000100721688 -[KSBaseModel encodeWithCoder:] (KSBaseModel.m:50)
21 XXX 0x00000001004434cc -[KSKVStorage writeObjectToFile:forKey:atomic:completion:] (KSKVStorage.m:0)
22 XXX 0x000000010326f550 -[KSLocalConfigManager internalRemoveLocalConfig:isGolbal:] (KSLocalConfigManager.m:273)
23 XXX 0x0000000103270330 +[KSLocalConfigManager removeLocalConfig:isGolbal:] (KSLocalConfigManager.m:0)
24 XXX 0x000000010326fa64 +[KSLocalConfigManager dailyCommonValueConfig:isGolbal:] (KSLocalConfigManager.m:0)
25 XXX 0x0000000100b55a30 -[KSKTVRoomViewController(InteractionGuide) checkIfShowGameOngoingView:] (KSKTVRoomViewController+InteractionGuide.m:0)
26 XXX 0x0000000100b54d38 -[KSKTVRoomViewController(InteractionGuide) showGameOngoingViewWhenEnterKTV:] (KSKTVRoomViewController+InteractionGuide.m:192)
37 XXX 0x00000001014ec7d4 main (main.m:37)
```

XXX Stack 2:

```
9 XXX 0x0000000103b94718 -[KSKitBaseModel encodeWithCoder:] (KSKitBaseModel.m:42)
11 XXX 0x00000001006c1688 -[KSBaseModel encodeWithCoder:] (KSBaseModel.m:50)
11 XXX 0x00000001006c1688 -[KSBaseModel encodeWithCoder:] (KSBaseModel.m:50)
21 XXX 0x00000001003e34cc -[KSKVStorage writeObjectToFile:forKey:atomic:completion:] (KSKVStorage.m:0)
22 XXX 0x000000010320ee7c -[KSLocalConfigManager internalSaveLocalConfig:value:isGolbal:] (KSLocalConfigManager.m:220)
23 XXX 0x000000010320fb10 +[KSLocalConfigManager saveLocalConfig:commonValue:isGolbal:] (KSLocalConfigManager.m:0)
24 XXX 0x0000000102152b94 -[KSSendGiftContainerView tabView:didChangeSelectIndex:] (KSSendGiftContainerView.m:1952)
25 XXX 0x000000010056235c -[KSTabView setSelectIndex:] (KSTabView.m:723)
28 XXX 0x00000001009ccbc4 -[KSBaseButton sendAction:to:forEvent:] (KSBaseButton.m:0)
46 XXX 0x000000010148c7d4 main (main.m:37)
```

### 2.2 Code analysis

All types of stacks eventually point to KSKVStorage writeeObjectToFile.

This is a storage control class where the object is archived and written to disk

Final stack point

```objective-c
0 libsystem_kernel.dylib 0x000000018aa97014 ___pthread_kill + 8
1 libsystem_c.dylib 0x000000018aa0b400 _abort + 140
2 libsystem_malloc.dylib 0x000000018aadba5c _nano_free_definite_size + 92
3 libsystem_malloc.dylib 0x000000018aadd028 _nano_realloc + 648
4 libsystem_malloc.dylib 0x000000018aacf240 _malloc_zone_realloc + 180
5 Foundation 0x000000018c5aa3e4 -[NSOperation isAsynchronous] + 180
6 Foundation 0x000000018c53c2a0 __decodeInt64 + 452
```

It can be considered that NsKeyedUnarchiver and NsKeyedArchiver triggered KSkitBaseModel and KSBaseModel's encodeWithCoder method.

Trigger encode WithCoder: The standard method for automatic sequencing is as follows:

```objective-c
- (void)encodeWithCoder:(NSCoder *)encoder {
	Class cls = [self class];
	while (cls != [NSObject class]) {
		unsigned int numberOfIvars = 0;
		Ivar* ivars = class_copyIvarList(cls, &numberOfIvars);
		for(const Ivar* p = ivars; p < ivars+numberOfIvars; p++)
		{
			Ivar const ivar = *p;
			const char *type = ivar_getTypeEncoding(ivar);
			NSString *key = [NSString stringWithUTF8String:ivar_getName(ivar)];
            if (key == nil){
                continue;
            }
            if ([key length] == 0){
                continue;
            }
            
			id value = [self valueForKey:key];
			if (value) {
				switch (type[0]) {
					case _C_STRUCT_B: {
						NSUInteger ivarSize = 0;
						NSUInteger ivarAlignment = 0;
						NSGetSizeAndAlignment(type, &ivarSize, &ivarAlignment);
						NSData *data = [NSData dataWithBytes:(const char *)((__bridge void *)self) + ivar_getOffset(ivar)
													  length:ivarSize];
						[encoder encodeObject:data forKey:key];
					}
						break;
					default:
						[encoder encodeObject:value
									   forKey:key];
						break;
				}
			}
		}
		if (ivars) {
			free(ivars);
		}
		
		cls = class_getSuperclass(cls);
	}
}

```

The above approach, through the runtime mechanism, goes through the properties of the current class and its parent, and it can be deduced that the brash triggers the following call sequence in a particular class or in a succession relationship.

```
[KSKitBaseModel encodeWithCoder:] (KSKitBaseModel.m:42)
[KSBaseModel encodeWithCoder:] (KSBaseModel.m:50)
[KSBaseModel encodeWithCoder:] (KSBaseModel.m:50)
```

The number of code lines may be incorrect.

Could happen in the archive of an object based on breakpoint debugging:

### 2.3 Positioning the problem

#### 2.3.1 Stack location

And looking at the stacks, the automatic sequenced KSBaseModel and KSKBaseModel base groups, which are persistent layers of KKC projects, occur in brash during automatic sequencing:

```objective-c
0 libsystem_kernel.dylib 0x000000018aa97014 ___pthread_kill + 8
1 libsystem_c.dylib 0x000000018aa0b400 _abort + 140
2 libsystem_malloc.dylib 0x000000018aadba5c _nano_free_definite_size + 92
3 libsystem_malloc.dylib 0x000000018aadd028 _nano_realloc + 648
4 libsystem_malloc.dylib 0x000000018aacf240 _malloc_zone_realloc + 180
5 Foundation 0x000000018c5aa3e4 -[NSOperation isAsynchronous] + 180
6 Foundation 0x000000018c53c2a0 __decodeInt64 + 452
7 XXX 0x0000000103cab808 -[KSKitBaseModel encodeWithCoder:] (KSKitBaseModel.m:42)
8 Foundation 0x000000018c53c49c __decodeIntXXX+ 416
9 XXX 0x00000001037a0b94 -[KSBaseModel encodeWithCoder:] (KSBaseModel.m:52)
……
```

In the absence of a problem with the automatic serialization code, it appears that the more direct litsystem_malloc.dylib caused a similar situation for the bugly and the micro-message team through a study of _nano_free_definite_size_size: [- iOS 10 nano_free Crash.](https://zhuanlan.zhihu.com/p/24342979)

#### 2.3.2 Positioning of problems

**From the analysis, the crash was made of iOS10 equipment, and the problem is that I-like stacks of equipment in iOS10 can be preliminarily identified as nano_free.**From the analysis, the crash was made of iOS10 equipment, and the problem is that I-like stacks of equipment in iOS10 can be preliminarily identified as nano_free.

#### 2.4 Recurrence

2.4.1 Constructing the conditions for recovery

```objective-c
- (void)addOperation{
    int count = 0;
    while (count < 10000) {
        [self.lock lock];
        //通过两台设备（iOS10 iPhone7P | iOS14 iPhone12）控制变量法模拟测试结论如下：
        //iOS10设备的问题：
        //通过修改 count % particle 中的 particle的值可以控制需要序列化的数组对象modelData的数据量，
        //实践证明，当 particle 值越大， modelData的数据量 越大，越容易发生crash
        //解决方案，控制每次序列化 数据量可以规避此crash
        //非iOS10设备未出现此问题
        NSString *key = [NSString stringWithFormat:@"%d",count];
        int particle = 5;
        if (count % particle == 1) {
            if (self.modelDataDict.allKeys.count > 0) {
                [self.modelDataDict removeObjectForKey:[self.modelDataDict.allKeys objectAtIndex:0]];
            }
            
        } else {
            KSModel *model = [[KSModel alloc] init];
            [self.modelDataDict setObject:model forKey:key];

        }
        [self.lock unlock];
        count ++;

        [self addopera:[self golbalSaveConfigKey] from:0 data:[self.modelDataDict mutableCopy]];

        NSLog(@"done index:%d datalen = %lu", count, (unsigned long)self.modelDataDict.allKeys.count);
    }
    
}

- (void)addopera:(NSString *) key from:(int) type data:(id<NSCoding, NSObject>)obj{
    
    __block NSData *value = nil;
    [_diskOperationQueue addOperationWithBlock:^{
        NSMutableString *str = [NSMutableString new];
        @try {
            value = [NSKeyedArchiver archivedDataWithRootObject:obj];
        }
        @catch (NSException *exception) {
            NSLog(@"exception = %@ ||  from = %d " ,exception ,type);
        }
        
        NSString *filePath = [ViewController migrateFileNameForKey:[NSString stringWithFormat:@"%@_%@_a", str, key]];
        NSError *error = nil;
        [value writeToFile:filePath options:NSDataWritingAtomic error:&error];
    }];
}


```

#### Simplify the K-song end-of-life code and recreate the environment in the new project. Simulate high frequency (HF) with the following core code for high data volume sustainability:

2.4.2 Comparison of control equipment variables

![](img/2021-09-13crash/Crash.png)

This code was run on iOS10 iPhone7P by the control device using a different iOS version of the device.

#### No such crash in iOS14 iPhone12

2.4.3 Control data level comparisons

```objective-c
2021-09-07 21:22:25.626353 PT-2[1187:35082] done index:9995 datalen = 2
2021-09-07 21:22:25.626385 PT-2[1187:35082] done index:9996 datalen = 1
2021-09-07 21:22:25.626456 PT-2[1187:35082] done index:9997 datalen = 2
2021-09-07 21:22:25.626520 PT-2[1187:35082] done index:9998 datalen = 1
2021-09-07 21:22:25.626584 PT-2[1187:35082] done index:9999 datalen = 2
2021-09-07 21:22:25.626610 PT-2[1187:35082] done index:10000 datalen = 1
```

By changing the value of the above-mentioned particle to 2 the iOS10 device will not occur; it can be demonstrated that there will be no crash at the time the required serialization data is smaller (at least in cases where the length is less than 2 =), and the running log indicates 10,000 circulation sequences:

```objective-c
2021-09-07 21:14:15.166295 PT-2[1087:32256] done index:8773 datalen = 5264
PT-2(1087,0x16dfe3000) malloc: *** error for object 0x173050000: Freeing unallocated pointer
*** set a breakpoint in malloc_error_break to debug
*** error for object 0x173050000: Freeing unallocated pointer
```

Clash occurs when the partyele exceeds a certain value and the number of loops reaches a certain number (i.e. the required sequenced array length is long enough) and, via logs, happens when the current recovery condition array reaches about 5,000, which may vary from the environment in the National K Song project:

The conditions for the above logs to occur in brash:

Number of loops: 8773

### The length of the sequenced array of data required is: 5264

2.5 Solutions

As a result of the above studies and practices, the problem arises in specific equipment and under specific conditions:

Specific equipment: iOS10.x

Specific equipment cannot be avoided.

Specific conditions: Large amount of sequenced data

The whole amount of data is re-sequenced when additions and deletions are found through the K-song persistent layer code reading. As a result of the above-mentioned recovery conditions [control data comparison]

By optimizing the sequencing of incremental data, the sequenced data can make it smaller, thus avoiding this crash.

Option I: CoreData replacement of NSKeyed Archiver sustainability programme

```objective-c
- (void)addOperation{
    int count = 0;
    while (count < 10000) {
        [self.lock lock];
        NSString *key = [NSString stringWithFormat:@"%d",count];
				KSModel *model = [[KSModel alloc] init];
        [self addopera:[self golbalSaveConfigKeyWithKey:key] from:0 data:model];
        [self.lock unlock];
        count ++;
        NSLog(@"done index:%d datalen = %lu", count, (unsigned long)self.modelDataDict.allKeys.count);
    }
}


```

Option II: Optimize the amount of NsKeyedArchiver data, with only sustainable incremental data at each time, which is no longer sustainable after NsMutableDictionary setObject, but will directly require sustainability of the target plus Key:

```objective-c
        id obj = [NSKeyedUnarchiver unarchiveObjectWithData:data];
```

There's only one element for each of these sequencings, as documented in iOS10. The X 10000 loops do not occur in brash, but the method is at the expense of ease of travel and needs to be retrieved from different storage files at counter-sequencing through Key values:

Supplement: There is also a need to ensure that the amount of data on the properties of the serialized objects is not excessive

### 3. Other

3.1 Risk

```
value = [NSKeyedArchiver archivedDataWithRootObject:obj];'archivedDataWithRootObject:' is deprecated: first deprecated in iOS 12.0 - Use +archivedDataWithRootObject:requiringSecureCoding:error: instead
```



 

