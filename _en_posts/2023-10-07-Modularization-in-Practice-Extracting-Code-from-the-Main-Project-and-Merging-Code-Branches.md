---
layout: post
lang: en
title: "Modularization in Practice: Extracting Code from the Main Project and Merging Code Branches"
subtitle: ""
date: 2023-10-07
author: "PaysonChen"
header-img: "img/home-bg-geek.jpg"
tags: []

---

# Componentization in Practice: Extracting Code from the Main Project and Merging Code Branches

## 1 Background

The componentization process inevitably encounters the following issues:

The componentization process is generally long, and business requirements are inevitably introduced during this process. This can lead to a situation:

The componentization branch has already migrated classes from the main project to the pod repository, and the business requirement code has modified these migrated classes during this period.

When merging code from the main branch (or other branch), if the main branch (or other branch) has modified the classes that were previously migrated, this can cause merge conflicts.

This type of conflict occurs when the entire class is marked with a "+" symbol and lacks a conflict symbol. In this case, it's not possible to resolve the conflict simply using tools or conflict symbols.

## 2 Problem Solving

To resolve this conflict, the initial approach was to use Xcode's built-in filemerge for comparison. However, this approach is prone to omissions and requires a lot of work, and doesn't fully utilize Git's conflict markers.

## 3 Better Solution

If you can identify which classes, when merging code, have been modified,

- [x]
- [x]
and have already been migrated (no main project exists),

then you can use these classes for conflict detection.

### 3.1 Conflict Resolution

The following briefly describes the conflict detection design approach.

#### 3.1.1 Data Preparation

First, perform a pre-merge. After the initial merge, you can view the conflicting class list file in SourceTree. Reviewing the conflict content, if changes are marked with a "+" throughout the file, then the file was migrated and modified by another branch.

![0](/img/2023-10-07-merge/0.jpg)

- Sort out the conflicting file lists generated by the pre-merge, define the list of file paths that are eligible for migration and modification as an array, and save it in the file: merge_project_files.txt

![1](/img/2023-10-07-merge/1.png)

 Move the path by selecting the class (you can select all and then move them together [mv]):

![2](/img/2023-10-07-merge/2.png)

***Tips: Use move (mv) instead of copy (cp) to restore the original state after the main project is modified, so that there will not be extra files that have been migrated but still exist in the main project***

You can obtain the conflicting file paths in the main project. Create a new text file and move all the conflicting class paths mentioned above to it.

```shell
/Users/username/Documents/Project/git/Inner/Demo/127/Demo-IOS/ProjectDemoiOS/ProjectDemoiOS/Class/Main/Car/Model/PSCCarDetailInforModel.h
/Users/username/Documents/Project/git/Inner/Demo/127/Demo-IOS/ProjectDemoiOS/ProjectDemoiOS/Class/Main/Sites/View/PSCPowerPriceTableViewCell.m
.....
```

- Map the above file list one by one to the local clone paths in the component library, define it as an array, and save it in the file merge_pods_files.txt

```
/Users/username/Documents/Project/git/CocoaPods/Private/ProjectCarModule/ProjectCarModule/Classes/Car/Model/DemoCarDetailInforModel.h
/Users/username/Documents/Project/git/CocoaPods/Private/ProjectExchangeMoudle/ProjectExchangeMoudle/Classes/Sites/View/DemoPowerPriceTableViewCell.m
.....
```

***Tips: Use commond+option+c to specify the file path***

#### 3.1.2 Algorithm Writing

- Step 1: In a new componentized branch (not pre-merged), copy the conflicting class files from the component library back to the main project.
- Step 2: Commit the local repository (no need to push to the remote repository) and then merge.
- Step 3: Merge conflicts are resolved by referencing historical changes.
- Step 4: After the merge is resolved, use the above solution to reverse the process, copying the dest main project directory and overwriting it with the component library file.

***Tip: Some deleted files may appear in the above list. In this case, they cannot be moved from the component library to the main project. Verify that they are unused files (not accidentally deleted).***

```shell
# merge.sh
# Read the source file path and destination folder path from an external file
#"source_paths.txt"
source_file=$1
#"destination_paths.txt"
destination_file=$2

# Check if the source file exists
if [ ! -f "$source_file" ]; then
echo "Source file '$source_file' does not exist."
exit 1
fi

# Check if the destination folder file exists
if [ ! -f "$destination_file" ]; then
echo "Source file '$source_file' does not exist."
exit 1
fi

# Ensure each record has a carriage return (the last line without a carriage return will be ignored)
while IFS = read -r source_path && IFS = read -r destination_folder <&3; do
source_paths += ("$source_path")
destination_paths += ("$destination_folder")
done < $source_file 3 < $destination_file

# Output array length
echo "Source file path array length: ${#source_paths[@]}"
echo "Destination folder path array length: ${#destination_paths[@]}"

#exit 0
# Traverse index
for index in "${!source_paths[@]}"; do
echo "Traverse destination folder path array, index="$index
source_path="${source_paths[$index]}"
destination_path="${destination_paths[$index]}"

# Construct the full path to the target file
# destination_path="${destination_folder}${source_path}"

# Check if the target file exists and delete it if it does
if [ -e "$destination_path" ]; then
rm "$destination_path"
fi

# Ensure the target folder exists
mkdir -p "$(dirname "$destination_path")"

# Move the source file to the target directory
mv "$source_path" "$destination_path"
done

echo "File move completed."

```

#### 3.1.3 Execution

To move files from the pod repository back to the main project:

```shell
sh merge.sh merge_pods_files.txt merge_project_files.txt
```

After resolving conflicts, move the above files from the main project back to the component repository.

```shell
sh merge.sh merge_project_files.txt merge_pods_files.txt
```

#### 3.1.4 Finalization

- After resolving conflicts, the Pod repository will contain the latest modified versions of the classes merged from the main branch (other feature branches), which need to be submitted to the corresponding migration Pod repository.
- The main project file retains the migrated version, allowing you to obtain the componentized project file structure.
- Execute the previously mentioned script to find existing classes that are not referenced by the project again for final cleanup.

```shell
function main() {

# Set the project directory
project_directory=$1

if [ -z "$1" ]; then
# The current directory is not passed as a parameter
project_directory=.
fi

# Set other directories
parent_path=$(dirname "$project_directory")
echo "Project path: "$parent_path"

current_dir=$(basename "$project_directory")
echo "Current path folder name: "$current_dir"

project_path=$(find "$parent_path"/$current_dir.xcodeproj -type f \( -name "*.pbxproj" \)) 
echo "project path:"$project_path 

all_file_path=$(find "$project_directory" -type f \( -name "*.h" \)) 
all_file_path_cnt=$(find "$project_directory" -type f \( -name "*.h" \) | wc -l) 

echo "Number of main project header files:"$all_file_path_cnt 

for src_file in $all_file_path; do 
# echo $src_file 
filename=$(basename "$src_file" .h) 
if ! grep -q "\b$filename\b" "$project_path"; then 
echo "project does not contain:"$src_file 
fi 
done
}


main $1

```

Pass in the project path (directory containing the project file):

```shell
sh find_all_file_no_project.sh /Users/username/Documents/Project/git/Inner/Demo/Release/Demo-IOS/ProjectiOS/ProjectiOS
```